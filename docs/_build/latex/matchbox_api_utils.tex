%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}


\title{matchbox\_api\_utils Documentation}
\date{Sep 13, 2017}
\release{0.15.3}
\author{Author}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{matchbox\_api\_utils package}
\label{\detokenize{matchbox_api_utils:matchbox-api-utils-package}}\label{\detokenize{matchbox_api_utils:welcome-to-matchbox-api-utils-s-documentation}}\label{\detokenize{matchbox_api_utils::doc}}

\section{Submodules}
\label{\detokenize{matchbox_api_utils:submodules}}

\section{matchbox\_api\_utils.matchbox module}
\label{\detokenize{matchbox_api_utils:module-matchbox_api_utils.matchbox}}\label{\detokenize{matchbox_api_utils:matchbox-api-utils-matchbox-module}}\index{matchbox\_api\_utils.matchbox (module)}\index{Matchbox (class in matchbox\_api\_utils.matchbox)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.matchbox.Matchbox}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{matchbox\_api\_utils.matchbox.}\sphinxbfcode{Matchbox}}{\emph{url}, \emph{creds}, \emph{make\_raw=None}}{}
Bases: \sphinxcode{object}

MATCHBox API Connector Class.

Basic connector class to make a call to the API and load the raw data. From
here we pass data, current MatchData or TreatmentArm data to appropiate calling
classes.

\end{fulllineitems}



\section{matchbox\_api\_utils.matchbox\_conf module}
\label{\detokenize{matchbox_api_utils:module-matchbox_api_utils.matchbox_conf}}\label{\detokenize{matchbox_api_utils:matchbox-api-utils-matchbox-conf-module}}\index{matchbox\_api\_utils.matchbox\_conf (module)}\index{Config (class in matchbox\_api\_utils.matchbox\_conf)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.matchbox_conf.Config}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{matchbox\_api\_utils.matchbox\_conf.}\sphinxbfcode{Config}}{\emph{mb\_config\_file=None}, \emph{mb\_json\_data=None}, \emph{ta\_json\_data=None}, \emph{amois\_lookup=None}}{}
Bases: \sphinxcode{object}
\index{read\_config() (matchbox\_api\_utils.matchbox\_conf.Config class method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.matchbox_conf.Config.read_config}}\pysiglinewithargsret{\sphinxbfcode{classmethod }\sphinxbfcode{read\_config}}{\emph{config\_file}}{}
\end{fulllineitems}


\end{fulllineitems}



\section{Module contents}
\label{\detokenize{matchbox_api_utils:module-contents}}\label{\detokenize{matchbox_api_utils:module-matchbox_api_utils}}\index{matchbox\_api\_utils (module)}\index{Matchbox (class in matchbox\_api\_utils)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.Matchbox}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{matchbox\_api\_utils.}\sphinxbfcode{Matchbox}}{\emph{url}, \emph{creds}, \emph{make\_raw=None}}{}
Bases: \sphinxcode{object}

MATCHBox API Connector Class.

Basic connector class to make a call to the API and load the raw data. From
here we pass data, current MatchData or TreatmentArm data to appropiate calling
classes.

\end{fulllineitems}

\index{MatchData (class in matchbox\_api\_utils)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.MatchData}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{matchbox\_api\_utils.}\sphinxbfcode{MatchData}}{\emph{config\_file=None}, \emph{url=None}, \emph{creds=None}, \emph{patient=None}, \emph{json\_db='sys\_default'}, \emph{load\_raw=None}, \emph{make\_raw=None}}{}
Bases: \sphinxcode{object}

MatchboxData class

Parsed MATCHBox Data from the API as collected from the Matchbox class above. This
class has methods to generate queries, further filtering, and heuristics on the
dataset.
\index{find\_variant\_frequency() (matchbox\_api\_utils.MatchData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.MatchData.find_variant_frequency}}\pysiglinewithargsret{\sphinxbfcode{find\_variant\_frequency}}{\emph{query}, \emph{query\_patients=None}}{}
Find and return variant hit rates.

Based on an input query in the form of a variant\_type : gene dict, where the gene value
can be a list of genes, output a list of patients that had hits in those gene with some
disease and variant information.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{query (dict): Dictionary of variant\_type: gene mappings where:}] \leavevmode\begin{itemize}
\item {} 
variant type is one or more of ‘snvs’,’indels’,’fusions’,’cnvs’

\item {} 
gene is a list of genes to query.

\end{itemize}

\end{description}

query\_patients (list): List of patients for which we want to obtain data.

\item[{Returns:}] \leavevmode
Will return a dict of matching data with disease and MOI information

\end{description}

Example:
\textgreater{}\textgreater{}\textgreater{} query=\{‘snvs’ : {[}‘BRAF’,’MTOR’{]}, ‘indels’ : {[}‘BRAF’, ‘MTOR’{]}\}
find\_variant\_frequency(query)

\end{fulllineitems}

\index{gen\_patients\_list() (matchbox\_api\_utils.MatchData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.MatchData.gen_patients_list}}\pysiglinewithargsret{\sphinxbfcode{gen\_patients\_list}}{\emph{matchbox\_data}, \emph{patient}}{}
Process the MATCHBox API data.

Process the MATCHBox API data (usually in JSON format from MongoDB) into
a much more concise and easily parsable dict of data. This dict will be
the main dataset used for later data analysis and queries and is the main
structure for the MatchboxData class below.
\begin{description}
\item[{Returns:}] \leavevmode
patients (dict): Dict of parsed MATCHBox API data.

\end{description}

\end{fulllineitems}

\index{get\_biopsy\_summary() (matchbox\_api\_utils.MatchData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.MatchData.get_biopsy_summary}}\pysiglinewithargsret{\sphinxbfcode{get\_biopsy\_summary}}{\emph{category=None}}{}
Return dict of patients registered in MATCHBox with biopsy and sequencing
information.

Categories returned are total PSNs issued (including outside
assay patients), total passed biopsies, total failed biopsies (per MDACC
message), total MSNs (only counting latest MSN if more than one issued to
a biopsy due to a failure) as a method of figuring out how many NAs were
prepared, and total with sequencing data.

Can filter output based on any one criteria by leveraging the “category”
variable
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{catetory (str): biopsy category to return. Valid categories are ‘psn’,’passed\_biopsy’,}] \leavevmode
‘failed\_biopsy’,’no\_biopsy’,’msn’,’sequenced’,’outside’.

\end{description}

\item[{Returns:}] \leavevmode
dict: whole set of category:count or single category:count data.

\end{description}

\end{fulllineitems}

\index{get\_bsn() (matchbox\_api\_utils.MatchData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.MatchData.get_bsn}}\pysiglinewithargsret{\sphinxbfcode{get\_bsn}}{\emph{psn=None}, \emph{msn=None}}{}
Retrieve a patient BSN from either an input PSN or MSN.
\begin{description}
\item[{Args:}] \leavevmode
psn (str): A PSN number to query.
msn (str): A MSN number to query.

\item[{Returns:}] \leavevmode
bsn (str): A BSN that maps to the PSN or MSN input.

\end{description}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{get\PYGZus{}bsn}\PYG{p}{(}\PYG{n}{psn}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{14420}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{T\PYGZhy{}17\PYGZhy{}000550}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{get\_disease\_summary() (matchbox\_api\_utils.MatchData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.MatchData.get_disease_summary}}\pysiglinewithargsret{\sphinxbfcode{get\_disease\_summary}}{\emph{disease=None}}{}
Return a summary of registered diseases and counts. Despite a MEDRA Code and other bits
of disease related data, we’ll rely on output from CTEP Term value only.
\begin{description}
\item[{Args:}] \leavevmode
query\_disease (str): Disease or comma separated list of diseases to filter on.

\item[{Returns:}] \leavevmode
Dictionary of disease(s) and counts.

\end{description}

\end{fulllineitems}

\index{get\_msn() (matchbox\_api\_utils.MatchData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.MatchData.get_msn}}\pysiglinewithargsret{\sphinxbfcode{get\_msn}}{\emph{psn=None}, \emph{bsn=None}}{}
Retrieve a patient BSN from either an input PSN or MSN.
\begin{description}
\item[{Args:}] \leavevmode
psn (str): A MSN number to query.
bsn (str): A BSN number to query.

\item[{Returns:}] \leavevmode
msn (str): A string of comma separated MSNs that map to an input BSN or PSN.

\end{description}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{get\PYGZus{}msn}\PYG{p}{(}\PYG{n}{bsn}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T\PYGZhy{}17\PYGZhy{}000550}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{MSN44180}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{get\_patient\_ta\_status() (matchbox\_api\_utils.MatchData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.MatchData.get_patient_ta_status}}\pysiglinewithargsret{\sphinxbfcode{get\_patient\_ta\_status}}{\emph{psn=None}}{}
Input a list of PSNs and return information about the treatment arm(s) to which they were
assigned, if they were assigned to any arms. If no PSN list is passed to the function, return
results for every PSN in the study.
\begin{description}
\item[{Args:}] \leavevmode
psn (list):  Optional list of PSNs to query.

\item[{Returns:}] \leavevmode
Dict of tuple of Status, Arm ID, and drug name.

\item[{Example:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{get\PYGZus{}patient\PYGZus{}ta\PYGZus{}status}\PYG{p}{(}\PYG{n}{psn}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10005}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}10005\PYGZsq{} : (u\PYGZsq{}OFF\PYGZus{}TRIAL\PYGZus{}NO\PYGZus{}TA\PYGZus{}AVAILABLE\PYGZsq{}, \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{}, \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{})\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{get\PYGZus{}patient\PYGZus{}ta\PYGZus{}status}\PYG{p}{(}\PYG{n}{psn}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10837}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}10837\PYGZsq{}: (u\PYGZsq{}ON\PYGZus{}TREATMENT\PYGZus{}ARM\PYGZsq{}, u\PYGZsq{}EAY131\PYGZhy{}Z1A\PYGZsq{}, u\PYGZsq{}Binimetinib\PYGZsq{})\PYGZcb{}}
\end{sphinxVerbatim}

\end{description}

\end{fulllineitems}

\index{get\_patients\_and\_disease() (matchbox\_api\_utils.MatchData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.MatchData.get_patients_and_disease}}\pysiglinewithargsret{\sphinxbfcode{get\_patients\_and\_disease}}{\emph{psn=None}, \emph{msn=None}, \emph{bsn=None}, \emph{outside=False}, \emph{no\_disease=False}}{}
Return dict of PSN:Disease for valid biopsies.  Valid biopsies can
are defined as being only Passed and can not be Failed, No Biopsy or
outside assay biopsies at this time.
\begin{description}
\item[{Args:}] \leavevmode
psn (str): Optional PSN or comma separated list of PSNs on which to filter data.
bsn (str): Optional BSN or comma separated list of BSNs on which to filter data.
msn (str): Optional MSN or comma separated list of MSNs on which to filter data.
outside (bool): Also include outside assay data. False by default.
no\_disease (bool): Return all data, even if there is no disease indicated for the
\begin{quote}

patient specimen. Default: False
\end{quote}

\item[{Returns:}] \leavevmode
Dict of PSN : Disease mappings. If no match for input ID, returns None.

\item[{Example:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{get\PYGZus{}disease}\PYG{p}{(}\PYG{n}{psn}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{11352}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}Serous endometrial adenocarcinoma\PYGZsq{}}
\end{sphinxVerbatim}

\end{description}

\end{fulllineitems}

\index{get\_patients\_by\_arm() (matchbox\_api\_utils.MatchData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.MatchData.get_patients_by_arm}}\pysiglinewithargsret{\sphinxbfcode{get\_patients\_by\_arm}}{\emph{armid}}{}
Input an arm ID and return a list of patients that are on the treatment arm

\end{fulllineitems}

\index{get\_psn() (matchbox\_api\_utils.MatchData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.MatchData.get_psn}}\pysiglinewithargsret{\sphinxbfcode{get\_psn}}{\emph{msn=None}, \emph{bsn=None}}{}
Retrieve a patient PSN from either an input MSN or BSN.
\begin{description}
\item[{Args:}] \leavevmode
msn (str): A MSN number to query.
bsn (str): A BSN number to query.

\item[{Returns:}] \leavevmode
psn (str): A PSN that maps to the MSN or BSN input.

\end{description}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{get\PYGZus{}psn}\PYG{p}{(}\PYG{n}{bsn}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T\PYGZhy{}17\PYGZhy{}000550}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{PSN14420}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{get\_seq\_datafile() (matchbox\_api\_utils.MatchData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.MatchData.get_seq_datafile}}\pysiglinewithargsret{\sphinxbfcode{get\_seq\_datafile}}{\emph{dtype=None}, \emph{msn=None}, \emph{psn=None}}{}~
Get path of VCF file from MB Obj and return the VCF file from either the MB mirror or the source.

\end{fulllineitems}

\index{get\_variant\_report() (matchbox\_api\_utils.MatchData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.MatchData.get_variant_report}}\pysiglinewithargsret{\sphinxbfcode{get\_variant\_report}}{\emph{psn=None}, \emph{msn=None}}{}
Input a PSN or MSN and return a tab delimited set of variant data for the patient
return var dict
psn, msn, bsn
disease

\end{fulllineitems}

\index{map\_msn\_psn() (matchbox\_api\_utils.MatchData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.MatchData.map_msn_psn}}\pysiglinewithargsret{\sphinxbfcode{map\_msn\_psn}}{\emph{pt\_id}, \emph{id\_type}}{}
Map a MSN to PSN or PSN to MSN

Note: This function is going to be deprecated in favor of individual calls.

NOTE: This function is deprecated in favor of individual get\_bsn, get\_psn,
get\_msn class of functions.
Given a patient ID (either MSN or PSN) and a type val, output corresponding
MSN / PSN mapping.
\begin{description}
\item[{Note:}] \leavevmode
If requesting an MSN as output, you will recieve an array of data since
there can be more than one MSN / PSN.  When requesting a PSN from an
MSN, you will recieve only one value.

\item[{Args:}] \leavevmode
pt\_id (str): Patient ID as either a MSN or PSN
id\_type (str): Type of ID input (‘msn’ \textbar{} ‘psn’).

\item[{Returns:}] \leavevmode
result (str): Corresponding MSN or PSN that maps to the input MSN or PSN.

\end{description}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{map\PYGZus{}msn\PYGZus{}psn}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{14420}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{psn}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[u\PYGZsq{}MSN44180\PYGZsq{}]}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{matchbox\_dump() (matchbox\_api\_utils.MatchData method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.MatchData.matchbox_dump}}\pysiglinewithargsret{\sphinxbfcode{matchbox\_dump}}{\emph{filename=None}}{}
Dump a parsed MATCHBox dataset.

Call to the API and make a JSON file that can later be loaded in, rather
than making an API call and reprocessing. Useful for quicker look ups as
the API call can be very, very slow with such a large DB.

\begin{sphinxadmonition}{note}{Note:}
This is a different dataset than the raw dump.
\end{sphinxadmonition}
\begin{description}
\item[{Args:}] \leavevmode
filename (str): Filename to use for output. Default filename is:
‘mb\_obj\_\textless{}date\_generated\textgreater{}.json’

\item[{Returns:}] \leavevmode
file: MATCHBox API JSON file.

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{TreatmentArms (class in matchbox\_api\_utils)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.TreatmentArms}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{matchbox\_api\_utils.}\sphinxbfcode{TreatmentArms}}{\emph{config\_file=None}, \emph{url=None}, \emph{creds=None}, \emph{json\_db='sys\_default'}, \emph{load\_raw=None}, \emph{make\_raw=False}}{}
Bases: \sphinxcode{object}

NCI-MATCH Treatment Arms and aMOIs Class
\index{get\_exclusion\_disease() (matchbox\_api\_utils.TreatmentArms method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.TreatmentArms.get_exclusion_disease}}\pysiglinewithargsret{\sphinxbfcode{get\_exclusion\_disease}}{\emph{armid}}{}
Input an arm ID and return a list of exclusionary diseases for the arm, if there are any. Otherwise
return None.
\begin{description}
\item[{Args:}] \leavevmode
armid (str): Full identifier of the arm to be queried.

\item[{Returns:}] \leavevmode
List of exclusionary diseases for the arm, or None if there aren’t any.

\item[{Example:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{get\PYGZus{}exclusion\PYGZus{}disease}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EAY131\PYGZhy{}Z1A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{[u\PYGZsq{}Melanoma\PYGZsq{}, u\PYGZsq{}Colorectal Cancer\PYGZsq{}]}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{get\PYGZus{}exclusion\PYGZus{}disease}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EAY131\PYGZhy{}Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{None}
\end{sphinxVerbatim}

\end{description}

\end{fulllineitems}

\index{make\_match\_arms\_db() (matchbox\_api\_utils.TreatmentArms method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.TreatmentArms.make_match_arms_db}}\pysiglinewithargsret{\sphinxbfcode{make\_match\_arms\_db}}{\emph{api\_data}}{}
Make a database of MATCH Treatment Arms.

Read in raw API data and create pared down JSON structure that can be easily parsed later one.

\end{fulllineitems}

\index{map\_amoi() (matchbox\_api\_utils.TreatmentArms method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.TreatmentArms.map_amoi}}\pysiglinewithargsret{\sphinxbfcode{map\_amoi}}{\emph{variant}}{}
Input a variant dict derived from some kind and return either an aMOI id in the form of Arm(i\textbar{}e). If
variant is not an aMOI, returns ‘None’.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{variant (dict):  Variant dict to annotate.  Dict must have the following keys in order to be}] \leavevmode\begin{quote}

valid:
\begin{itemize}
\item {} 
type : {[}snvs\_indels, cnvs, fusions{]}

\item {} 
oncomineVariantClass

\item {} 
gene

\item {} 
identifier (i.e. variant ID (COSM476))

\item {} 
exon

\item {} 
function

\end{itemize}
\end{quote}

Not all variant types will have meaningful data for these fields, and so fields
may be padded with a null char (e.g. ‘.’, ‘-‘, ‘NA’, etc.).

\end{description}

\item[{Returns}] \leavevmode
results (list):  Arm ID(s) with (i)nclusion or (e)xclusion information.

\item[{Example:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{variant} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{type}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{snvs\PYGZus{}indels}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gene}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{BRAF}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{identifier}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{COSM476}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exon}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{15}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{function}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{missense}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{oncominevariantclass}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hotspot}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{\PYGZcb{}}
\PYG{g+go}{[\PYGZsq{}EAY131\PYGZhy{}Y(e)\PYGZsq{}, \PYGZsq{}EAY131\PYGZhy{}P(e)\PYGZsq{}, \PYGZsq{}EAY131\PYGZhy{}N(e)\PYGZsq{}, \PYGZsq{}EAY131\PYGZhy{}H(i)\PYGZsq{}]}
\end{sphinxVerbatim}

\end{description}

\end{fulllineitems}

\index{map\_drug\_arm() (matchbox\_api\_utils.TreatmentArms method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.TreatmentArms.map_drug_arm}}\pysiglinewithargsret{\sphinxbfcode{map\_drug\_arm}}{\emph{armid=None}, \emph{drugname=None}}{}
Input an Arm ID or a drug name, and retun a tuple of arm, drugname, and ID. If no arm ID or
drug name is input, will return a whole table of all arm data.
\begin{description}
\item[{Args:}] \leavevmode
armid (str): Offcial NCI-MATCH Arm ID in the form of EAY131-xxx (e.g. EAY131-Z1A).
drugname (str): Drug name as registered in the NCI-MATCH subprotocols.  Right now,
\begin{quote}

required to have the full string (e.g. ‘MLN0128(TAK-228)’ or, unfortunately,
‘Sunitinib malate (SU011248 L-malate)’), but will work on a regex to
help later on.
\end{quote}

\item[{Returns:}] \leavevmode
List of tuples or None.

\item[{Example:}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{map\PYGZus{}drug\PYGZus{}arm}\PYG{p}{(}\PYG{n}{armid}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EAY131\PYGZhy{}Z1A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{(u\PYGZsq{}EAY131\PYGZhy{}Z1A\PYGZsq{}, \PYGZsq{}Binimetinib\PYGZsq{}, u\PYGZsq{}788187\PYGZsq{})}
\end{sphinxVerbatim}

\end{description}

\end{fulllineitems}

\index{ta\_json\_dump() (matchbox\_api\_utils.TreatmentArms method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{matchbox_api_utils:matchbox_api_utils.TreatmentArms.ta_json_dump}}\pysiglinewithargsret{\sphinxbfcode{ta\_json\_dump}}{\emph{amois\_filename=None}, \emph{ta\_filename=None}}{}
Dump the TreatmentArms data to a JSON file that can be easily loaded downstream. We will make both the
treatment arms object, as well as the amois lookup table object.
\begin{description}
\item[{Args:}] \leavevmode
amois\_filename (str): Name of aMOI lookup JSON file. Default: amoi\_lookup\_\textless{}datestring\textgreater{}.json
ta\_filename (str): Name of TA object JSON file Default: ta\_obj\_\textless{}datestring\textgreater{}.json

\item[{Returns:}] \leavevmode
ta\_obj\_\textless{}date\textgreater{}.json
amois\_lookup\_\textless{}date\textgreater{}.json

\end{description}

\end{fulllineitems}


\end{fulllineitems}


matchbox\_api\_utils

Description of this package coming soon.  For now consult the individual files in the ‘bin’ directory.
\begin{itemize}
\item {} 
Note: Don’t use pip to install…won’t run the post installer script!

\end{itemize}

v0.1dev, 6/13/2017 \textendash{} Initial release


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\label{\detokenize{index::doc}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{m}
\item {\sphinxstyleindexentry{matchbox\_api\_utils}}\sphinxstyleindexpageref{matchbox_api_utils:\detokenize{module-matchbox_api_utils}}
\item {\sphinxstyleindexentry{matchbox\_api\_utils.matchbox}}\sphinxstyleindexpageref{matchbox_api_utils:\detokenize{module-matchbox_api_utils.matchbox}}
\item {\sphinxstyleindexentry{matchbox\_api\_utils.matchbox\_conf}}\sphinxstyleindexpageref{matchbox_api_utils:\detokenize{module-matchbox_api_utils.matchbox_conf}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}